
// Tests ways that we can mark things as having failed

// import expect.js
let expect = require( 'expect.js' )

// import all relevant classes
const { LC, Statement, Environment } = require( '../classes/all.js' )

suite( 'Failures', () => {

  test( 'If we don\'t mark quantifiers w/failures, they bind stuff', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'exists' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~exists' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
  } )

  test( 'Quantifiers marked with no failures behave the same', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.be.ok()
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.be.ok()
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'exists' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~exists' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
  } )

  test( 'Quantifiers marked with failures don\'t bind that stuff', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    stmt.markFailures( [ 'x' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ 'x', 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x', 'y' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    stmt.markFailures( [ 'x' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt.markFailures( [ 'x', 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    let inner = stmt.child( 1 )
    expect( inner.isAQuantifier ).to.be( true )
    inner.markFailures( [ 'x' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( true )
    inner.markFailures( [ 'x', 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( true )
    inner.markFailures( [ ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
  } )

  test( 'validateQuantifiers() works for ~forall(x,y,P(x,y))', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    // consider when no constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 2 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when an irrelevant constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ 'k' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 2 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when x is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'x' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( true )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 2 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when y is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'y' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.child( 2 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
  } )

  test( 'validateQuantifiers() works for ~forall(x,~exists(y,P(x,y))', () => {
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    let inner = stmt.child( 1 )
    // consider when no constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when an irrelevant constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ 'k' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when x is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'x' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when y is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'y' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( true )
    expect( stmt.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.first.getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.child( 1 ).getAttribute( 'binding failures' ) )
      .to.be( undefined )
  } )

  test( 'Marking non-quantifiers with binding failures does nothing', () => {
    dec = LC.fromString( '~forall(x,thing(y,P(x,y)))' )
    let inner = dec.child( 1 )
    expect( inner.isAQuantifier ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'x' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'x', 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
  } )

  test( 'If we don\'t mark declarations w/failures, they declare stuff', () => {
    let dec = LC.fromString( '{ x y P(x,y) }' )
    dec.declaration = 'constant'
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'z' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'P' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( false )
    dec = LC.fromString( '{ x { y P(x,y) } }' )
    dec.declaration = 'variable'
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'z' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'P' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( false )
  } )

  test( 'Declarations marked with no failures behave the same', () => {
    let dec = LC.fromString( '{ x y P(x,y) }' )
    dec.declaration = 'constant'
    dec.markFailures( [ ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.be.ok()
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'z' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'P' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( false )
    dec = LC.fromString( '{ x { y P(x,y) } }' )
    dec.declaration = 'variable'
    dec.markFailures( [ ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.be.ok()
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'z' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'P' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( false )
  } )

  test( 'Declarations marked failures don\'t declare that stuff', () => {
    let dec = LC.fromString( '{ x y P(x,y) }' )
    dec.declaration = 'constant'
    dec.markFailures( [ 'x' ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ 'x' ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( true )
    expect( dec.declarationFailed() ).to.be( true )
    dec.markFailures( [ 'y' ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ 'y' ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( true )
    dec.markFailures( [ 'x', 'y' ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ 'x', 'y' ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( true )
    dec.markFailures( [ ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( true )
    expect( dec.declarationFailed() ).to.be( false )
    dec = LC.fromString( '{ x { y P(x,y) } }' )
    dec.declaration = 'variable'
    dec.markFailures( [ 'x' ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ 'x' ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( true )
    dec.markFailures( [ 'y' ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( false )
    dec.markFailures( [ 'x', 'y' ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ 'x' ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( false )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( true )
    dec.markFailures( [ ] )
    expect( dec.getAttribute( 'declaration failures' ) ).to.eql( [ ] )
    expect( dec.successfullyDeclares( 'x' ) ).to.be( true )
    expect( dec.successfullyDeclares( 'y' ) ).to.be( false )
    expect( dec.declarationFailed() ).to.be( false )
  } )

  test( 'Marking non-declarations w/declaration failures does nothing', () => {
    dec = LC.fromString( '{ x { y P(x,y) } }' )
    let inner = dec.child( 1 )
    expect( inner.canBeADeclaration() ).to.be( true )
    expect( inner.declaration ).to.be( 'none' )
    expect( inner.getAttribute( 'declaration failures' ) ).to.be( undefined )
    expect( inner.successfullyDeclares( 'x' ) ).to.be( false )
    expect( inner.successfullyDeclares( 'y' ) ).to.be( false )
    expect( inner.declarationFailed() ).to.be( false )
    inner.markFailures( [ 'x' ] )
    expect( inner.getAttribute( 'declaration failures' ) ).to.be( undefined )
    expect( inner.successfullyDeclares( 'x' ) ).to.be( false )
    expect( inner.successfullyDeclares( 'y' ) ).to.be( false )
    expect( inner.declarationFailed() ).to.be( false )
    inner.markFailures( [ 'y' ] )
    expect( inner.getAttribute( 'declaration failures' ) ).to.be( undefined )
    expect( inner.successfullyDeclares( 'x' ) ).to.be( false )
    expect( inner.successfullyDeclares( 'y' ) ).to.be( false )
    expect( inner.declarationFailed() ).to.be( false )
    inner.markFailures( [ 'x', 'y' ] )
    expect( inner.getAttribute( 'declaration failures' ) ).to.be( undefined )
    expect( inner.successfullyDeclares( 'x' ) ).to.be( false )
    expect( inner.successfullyDeclares( 'y' ) ).to.be( false )
    expect( inner.declarationFailed() ).to.be( false )
    inner.markFailures( [ ] )
    expect( inner.getAttribute( 'declaration failures' ) ).to.be( undefined )
    expect( inner.successfullyDeclares( 'x' ) ).to.be( false )
    expect( inner.successfullyDeclares( 'y' ) ).to.be( false )
    expect( inner.declarationFailed() ).to.be( false )
  } )

} )
