
// Tests ways that we can mark things as having failed

// import expect.js
let expect = require( 'expect.js' )

// import all relevant classes
const { LC, Statement, Environment } = require( '../classes/all.js' )

suite( 'Failures', () => {

  test( 'If we don\'t mark quantifiers w/failures, they bind stuff', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'exists' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~exists' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
  } )

  test( 'Quantifiers marked with no failures behave the same', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.be.ok()
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.be.ok()
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'z' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'P' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~forall' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'exists' ) ).to.be( false )
    expect( stmt.successfullyBinds( '~exists' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
  } )

  test( 'Quantifiers marked with failures don\'t bind that stuff', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    stmt.markFailures( [ 'x' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ 'x', 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x', 'y' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    stmt.markFailures( [ 'x' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    stmt.markFailures( [ 'x', 'y' ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    stmt.markFailures( [ ] )
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( false )
    let inner = stmt.children()[1]
    expect( inner.isAQuantifier ).to.be( true )
    inner.markFailures( [ 'x' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( true )
    inner.markFailures( [ 'x', 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( true )
    inner.markFailures( [ ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
  } )

  test( 'validateQuantifiers() works for ~forall(x,y,P(x,y))', () => {
    let stmt = LC.fromString( '~forall(x,y,P(x,y))' )
    // consider when no constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[2].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when an irrelevant constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ 'k' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[2].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when x is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'x' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( true )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[2].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when y is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'y' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.successfullyBinds( 'y' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( stmt.children()[2].getAttribute( 'binding failures' ) )
      .to.be( undefined )
  } )

  test( 'validateQuantifiers() works for ~forall(x,~exists(y,P(x,y))', () => {
    stmt = LC.fromString( '~forall(x,~exists(y,P(x,y)))' )
    let inner = stmt.children()[1]
    // consider when no constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when an irrelevant constants exist in the environment
    expect( () => stmt.validateQuantifiers( [ 'k' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when x is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'x' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ 'x' ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( false )
    expect( stmt.quantifierFailed() ).to.be( true )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( true )
    expect( inner.quantifierFailed() ).to.be( false )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    // consider when y is a constant in the environment
    expect( () => stmt.validateQuantifiers( [ 'y' ] ) ).to.not.throwException()
    expect( stmt.getAttribute( 'binding failures' ) ).to.eql( [ ] )
    expect( stmt.successfullyBinds( 'x' ) ).to.be( true )
    expect( stmt.quantifierFailed() ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.eql( [ 'y' ] )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( true )
    expect( stmt.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[0].getAttribute( 'binding failures' ) )
      .to.be( undefined )
    expect( inner.children()[1].getAttribute( 'binding failures' ) )
      .to.be( undefined )
  } )

  test( 'Marking non-quantifiers with binding failures does nothing', () => {
    dec = LC.fromString( '~forall(x,thing(y,P(x,y)))' )
    let inner = dec.children()[1]
    expect( inner.isAQuantifier ).to.be( false )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'x' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ 'x', 'y' ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
    inner.markFailures( [ ] )
    expect( inner.getAttribute( 'binding failures' ) ).to.be( undefined )
    expect( inner.successfullyBinds( 'x' ) ).to.be( false )
    expect( inner.successfullyBinds( 'y' ) ).to.be( false )
    expect( inner.quantifierFailed() ).to.be( false )
  } )

} )
